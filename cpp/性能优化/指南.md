# 性能优化指南

## 本章概览

- 构建一个统一的性能测量体系,用于观察交易平台与交易客户端的延迟
- 在关键组件中插桩,获取 CPU 周期与纳秒级时间戳,覆盖端到端链路
- 讨论 RDTSC 等测量技术的优势、局限以及实际部署时需关注的细节
- 演示在交易所与交易客户端两侧加入测量点后的运行与日志输出

## 技术要求与环境

- 操作系统: `Linux 5.19.0-41-generic #42~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Tue Apr 18 17:40:00 UTC 2 x86_64`
- 编译器: `g++ (Ubuntu 11.3.0-1ubuntu1~22.04.1) 11.3.0`
- 构建工具: `cmake 3.23.2`, `ninja 1.10.2`
- 源码目录: 仓库 `Chapter11`
- 前置章节: 匹配引擎、市场参与者通信、市场数据处理、交易算法基础模块、做市与流动性获取算法

> 所有代码位于 `Chapter11` 目录,并建立在前面章节实现的电子交易生态系统之上。

## 添加检测工具系统以测量系统性能

性能数据既可以用于比较内部组件的 延迟,也可以用于分析跨组件的传播耗时。首要工作是引入一组通用的测量工具,支持同机与跨机情况下的性能采集。

### 使用 RDTSC 的性能测量工具

- **RDTSC** 用于读取时间戳计数器(Time Stamp Counter, TSC),返回 CPU 周期数。
- 通过执行 `rdtsc` 汇编指令,分别取得低 32 位(`lo`)与高 32 位(`hi`)后合成 64 位值。
- 不进行时间换算时,可以直接比较周期差;若需要换算,需除以 CPU 频率。

示例: 在频率约为 2.6GHz 的系统上,差值 26 周期 ≈ `26 ÷ 2.6 = 10` 纳秒。

```bash
root@mydevserver:~/Building-Low-Latency-Applications-with-CPP/Chapter11$ cat /proc/cpuinfo | grep MHz
cpu MHz         : 2645.048
cpu MHz         : 2645.035
cpu MHz         : 2645.033
cpu MHz         : 2645.050
```

`Chapter11/common/perf_utils.h` 中新增以下实用方法与宏:

```cpp
#pragma once
namespace Common {
inline auto rdtsc() noexcept {
        unsigned int lo, hi;
        asm volatile ("rdtsc" : "=a" (lo), "=d" (hi));
        return (static_cast<uint64_t>(hi) << 32) | lo;
}
}
```

```cpp
#define START_MEASURE(TAG) const auto TAG = Common::rdtsc()

#define END_MEASURE(TAG, LOGGER)                              \
do {                                                         \
        const auto end = Common::rdtsc();                         \
        LOGGER.log("% RDTSC " #TAG " %\n",                    \
                             Common::getCurrentTimeStr(&time_str_),         \
                             (end - TAG));                                  \
} while (false)

#define TTT_MEASURE(TAG, LOGGER)                              \
do {                                                         \
        const auto TAG = Common::getCurrentNanos();               \
        LOGGER.log("% TTT " #TAG " %\n",                    \
                             Common::getCurrentTimeStr(&time_str_),         \
                             TAG);                                          \
} while (false)
```

- `START_MEASURE(TAG)` 创建变量 `TAG`,保存 `rdtsc()` 结果。
- `END_MEASURE(TAG, LOGGER)` 再次读取 TSC,记录差值。
- `TTT_MEASURE(TAG, LOGGER)` 记录纳秒级时间戳(调用 `Common::getCurrentNanos()`)。

### 更新时间实用工具

- `Common::getCurrentTimeStr()` 现在以 `HH:MM:SS.nnnnnnnnn` 输出,便于分析同秒内事件。
- 增加了对 `perf_utils.h` 的包含。

```cpp
namespace Common {
inline auto& getCurrentTimeStr(std::string* time_str) {
        const auto clock = std::chrono::system_clock::now();
        const auto time  = std::chrono::system_clock::to_time_t(clock);

        char nanos_str[24];
        sprintf(nanos_str, "%.8s.%09ld",
                        ctime(&time) + 11,
                        std::chrono::duration_cast<std::chrono::nanoseconds>(clock.time_since_epoch()).count() % NANOS_TO_SECS);
        time_str->assign(nanos_str);
        return *time_str;
}
}
```

### 实际测量时的注意事项

- **测量开销**: 插桩本身会带来额外延迟。对纳秒级操作使用 `rdtsc()` 可最小化影响。
- **RDTSC 局限**: 可移植性有限;跨核心的频率差异会影响周期到时间的换算准确性。
- **环境调优**: 为获得稳定数据,通常需要禁用中断、关闭无关进程、合理配置 NUMA、固化 CPU 频率、绑定线程到核心等。详见《开发高频交易系统》中的相关章节。

## 测量交易所的延迟

交易所侧需要同时关注内部函数的执行时间以及事件在各子系统之间的传播延迟。

### 内部测量目标

- `Common::McastSocket::send()`
- `Exchange::MEOrderBook::add()`
- `Exchange::MEOrderBook::cancel()`
- `Exchange::MatchingEngine::processClientRequest()`
- `Exchange::MEOrderBook::removeOrder()`
- `Exchange::MEOrderBook::match()`(多处调用)
- `Exchange::MEOrderBook::checkForMatch()`
- `Exchange::MEOrderBook::addOrder()`
- `Common::TCPSocket::send()`
- `Exchange::FIFOSequencer::addClientRequest()`
- `Exchange::FIFOSequencer::sequenceAndPublish()`

### 关键时间戳节点

- `T1_OrderServer_TCP_read`: 订单服务器 TCP 套接字读取客户请求的时间
- `T2_OrderServer_LFQueue_write`: 请求写入匹配引擎无锁队列的时间
- `T3_MatchingEngine_LFQueue_read`: 匹配引擎读取客户请求的时间
- `T4_MatchingEngine_LFQueue_write`: 市场更新写入市场数据发布者无锁队列的时间
- `T4t_MatchingEngine_LFQueue_write`: 客户响应写入订单服务器无锁队列的时间
- `T5_MarketDataPublisher_LFQueue_read`: 市场数据发布者读取市场更新的时间
- `T5t_OrderServer_LFQueue_read`: 订单服务器读取客户响应的时间
- `T6_MarketDataPublisher_UDP_write`: 市场更新写入 UDP 套接字的时间
- `T6t_OrderServer_TCP_write`: 客户响应写入 TCP 套接字的时间

图 11.1 展示了带有时间戳节点的交易所拓扑结构。

### 市场数据发布者(`market_data_publisher.cpp`)

- 在 `MarketDataPublisher::run()` 中,读取无锁队列后记录 `T5_MarketDataPublisher_LFQueue_read`。
- 使用 `START_MEASURE`/`END_MEASURE` 与标签 `Exchange_McastSocket_send` 测量 `MCastSocket::send()`。
- 完成套接字写入后,记录 `T6_MarketDataPublisher_UDP_write`。

### 订单服务器(`order_server.h`)

- `OrderServer::run()`:
    - 读取无锁队列时标记 `T5t_OrderServer_LFQueue_read`。
    - 发送响应时测量 `Exchange_TCPSocket_send`,并记录 `T6t_OrderServer_TCP_write`。
- `OrderServer::recvCallback()`:
    - 入场记录 `T1_OrderServer_TCP_read`。
    - 包裹 `FIFOSequencer::addClientRequest()` 以测量 `Exchange_FIFOSequencer_addClientRequest`。
- `OrderServer::recvFinishedCallback()`:
    - 测量 `FIFOSequencer::sequenceAndPublish()` 对应的 `Exchange_FIFOSequencer_sequenceAndPublish`。

### FIFOSequencer(`fifo_sequencer.h`)

- 在 `sequenceAndPublish()` 中,每次写入无锁队列后记录 `T2_OrderServer_LFQueue_write`。

### 撮合引擎(`matching_engine.h`)

- `processClientRequest()`:
    - 测量 `MEOrderBook::add()`(`Exchange_MEOrderBook_add`) 与 `MEOrderBook::cancel()`(`Exchange_MEOrderBook_cancel`)。
- `sendClientResponse()`:
    - 写入响应队列后记录 `T4t_MatchingEngine_LFQueue_write`。
- `sendMarketUpdate()`:
    - 写入市场更新队列后记录 `T4_MatchingEngine_LFQueue_write`。
- `run()`:
    - 读取请求时记录 `T3_MatchingEngine_LFQueue_read`。
    - 包裹 `processClientRequest()` 以测量 `Exchange_MatchingEngine_processClientRequest`。

### 订单簿(`me_order_book.cpp`)

- `MEOrderBook::match()`:
    - 测量 `removeOrder()`(`Exchange_MEOrderBook_removeOrder`)。
- `MEOrderBook::checkForMatch()`:
    - 两个分支均测量 `match()`(`Exchange_MEOrderBook_match`)。
- `MEOrderBook::add()`:
    - 测量 `checkForMatch()`(`Exchange_MEOrderBook_checkForMatch`) 与 `addOrder()`(`Exchange_MEOrderBook_addOrder`)。
- `MEOrderBook::cancel()`:
    - 测量 `removeOrder()`(`Exchange_MEOrderBook_removeOrder`)。

## 测量交易引擎中的延迟

交易客户端同样需要内部测量与事件时间戳,以分析市场数据与订单响应的传输延迟。

### 内部测量目标

- `Trading::MarketDataConsumer::recvCallback()`
- `Common::TCPSocket::send()`
- `Trading::OrderGateway::recvCallback()`
- `Trading::OrderManager::moveOrders()`(多次)
- `Trading::OrderManager::onOrderUpdate()`(多次)
- `Trading::MarketOrderBook::addOrder()`
- `Trading::MarketOrderBook::removeOrder()`
- `Trading::MarketOrderBook::updateBBO()`
- `Trading::OrderManager::cancelOrder()`
- `Trading::RiskManager::checkPreTradeRisk()`
- `Trading::OrderManager::newOrder()`
- `Trading::OrderManager::moveOrder()`(多次)
- `Trading::PositionKeeper::updateBBO()`
- `Trading::FeatureEngine::onOrderBookUpdate()`
- `Trading::TradeEngine::algoOnOrderBookUpdate()`
- `Trading::FeatureEngine::onTradeUpdate()`
- `Trading::TradeEngine::algoOnTradeUpdate()`
- `Trading::PositionKeeper::addFill()`
- `Trading::TradeEngine::algoOnOrderUpdate()`

### 关键时间戳节点

- `T7_MarketDataConsumer_UDP_read`: 市场数据消费者读取 UDP 数据
- `T7t_OrderGateway_TCP_read`: 订单网关读取 TCP 响应
- `T8_MarketDataConsumer_LFQueue_write`: 市场数据写入交易引擎无锁队列
- `T8t_OrderGateway_LFQueue_write`: 客户端响应写入交易引擎无锁队列
- `T9_TradeEngine_LFQueue_read`: 交易引擎读取市场数据
- `T9t_TradeEngine_LFQueue_read`: 交易引擎读取客户端响应
- `T10_TradeEngine_LFQueue_write`: 交易引擎写出客户端请求
- `T11_OrderGateway_LFQueue_read`: 订单网关读取交易引擎请求
- `T12_OrderGateway_TCP_write`: 订单网关将请求写入 TCP

图 11.2 展示了客户端系统的时间戳拓扑。

### 市场数据消费者(`market_data_consumer.cpp`)

- `recvCallback()`:
    - 入场记录 `T7_MarketDataConsumer_UDP_read`。
    - 包裹整个方法以测量 `Trading_MarketDataConsumer_recvCallback`。
    - 写入无锁队列后记录 `T8_MarketDataConsumer_LFQueue_write`。

### 订单网关(`order_gateway.cpp`)

- `run()`:
    - 读取请求时记录 `T11_OrderGateway_LFQueue_read`。
    - 测量 `Common::TCPSocket::send()`(`Trading_TCPSocket_send`),之后记录 `T12_OrderGateway_TCP_write`。
- `recvCallback()`:
    - 入场记录 `T7t_OrderGateway_TCP_read`。
    - 包裹整个方法(`Trading_OrderGateway_recvCallback`)。
    - 写入无锁队列后记录 `T8t_OrderGateway_LFQueue_write`。

### 交易引擎(`trade_engine.cpp`)

- `sendClientRequest()`:
    - 写入订单网关无锁队列后记录 `T10_TradeEngine_LFQueue_write`。
- `run()`:
    - 读取客户端响应时记录 `T9t_TradeEngine_LFQueue_read`。
    - 读取市场更新时记录 `T9_TradeEngine_LFQueue_read`。
- `onOrderBookUpdate()`:
    - 测量 `PositionKeeper::updateBBO()`(`Trading_PositionKeeper_updateBBO`)
    - 测量 `FeatureEngine::onOrderBookUpdate()`(`Trading_FeatureEngine_onOrderBookUpdate`)
    - 测量 `algoOnOrderBookUpdate_`(`Trading_TradeEngine_algoOnOrderBookUpdate_`)
- `onTradeUpdate()`:
    - 测量 `FeatureEngine::onTradeUpdate()`(`Trading_FeatureEngine_onTradeUpdate`)
    - 测量 `algoOnTradeUpdate_`(`Trading_TradeEngine_algoOnTradeUpdate_`)
- `onOrderUpdate()`:
    - 在填单时测量 `PositionKeeper::addFill()`(`Trading_PositionKeeper_addFill`)
    - 包裹 `algoOnOrderUpdate_`(`Trading_TradeEngine_algoOnOrderUpdate_`)

### 订单管理器(`order_manager.h`)

- `moveOrder()`:
    - 测量 `cancelOrder()`(`Trading_OrderManager_cancelOrder`)
    - 测量 `risk_manager_.checkPreTradeRisk()`(`Trading_RiskManager_checkPreTradeRisk`)
    - 测量 `newOrder()`(`Trading_OrderManager_newOrder`)
- `moveOrders()`:
    - 多次调用 `moveOrder()` 时测量 `Trading_OrderManager_moveOrder`

### 市场订单簿(`market_order_book.cpp`)

- `onMarketUpdate()`:
    - `MarketUpdateType::ADD` 分支测量 `addOrder()`(`Trading_MarketOrderBook_addOrder`)
    - `MarketUpdateType::CANCEL` 分支测量 `removeOrder()`(`Trading_MarketOrderBook_removeOrder`)
    - 更新 BBO 时测量 `updateBBO()`(`Trading_MarketOrderBook_updateBBO`)

### 流动性获取者(`liquidity_taker.h`)

- `onTradeUpdate()`:
    - 触发下单时测量 `OrderManager::moveOrders()`(`OrderManager_moveOrders`)
- `onOrderUpdate()`:
    - 包裹 `OrderManager::onOrderUpdate()`(`Trading_OrderManager_onOrderUpdate`)

### 做市商(`market_maker.h`)

- `onOrderBookUpdate()`:
    - 测量 `OrderManager::moveOrders()`(`Trading_OrderManager_moveOrders`)
- `onOrderUpdate()`:
    - 包裹 `OrderManager::onOrderUpdate()`(`Trading_OrderManager_onOrderUpdate`)

## 使用新的测量系统运行整个生态系统

启动脚本保持不变:

```bash
root@mydevserver:~/Building-Low-Latency-Applications-with-CPP/Chapter11$ bash scripts/run_exchange_and_clients.sh
```

运行后可以在日志中观察到新的 RDTSC 与 TTT 记录:

```bash
root@mydevserver:~/Building-Low-Latency-Applications-with-CPP/Chapter11$ grep Exchange_MEOrderBook_match *.log
exchange_matching_engine.log:02:42:59.980424597 RDTSC Exchange_MEOrderBook_match 205247
exchange_matching_engine.log:02:43:00.022326352 RDTSC Exchange_MEOrderBook_match 216239

root@mydevserver:~/Building-Low-Latency-Applications-with-CPP/Chapter11$ grep Trading_MarketOrderBook_addOrder *.log
trading_engine_1.log:02:44:18.894251975 RDTSC Trading_MarketOrderBook_addOrder 204
trading_engine_1.log:02:44:18.904221378 RDTSC Trading_MarketOrderBook_addOrder 971

root@mydevserver:~/Building-Low-Latency-Applications-with-CPP/Chapter11$ grep T6_MarketDataPublisher_UDP_write *.log
exchange_market_data_publisher.log:02:40:13.596201293 TTT T6_MarketDataPublisher_UDP_write 1685864413596201240
exchange_market_data_publisher.log:02:40:13.624236967 TTT T6_MarketDataPublisher_UDP_write 1685864413624236907

root@mydevserver:~/Building-Low-Latency-Applications-with-CPP/Chapter11$ grep T8t_OrderGateway_LFQueue_write *.log
trading_order_gateway_1.log:02:40:14.524401434 TTT T8t_OrderGateway_LFQueue_write 1685864414524401386
trading_order_gateway_1.log:02:40:14.524425862 TTT T8t_OrderGateway_LFQueue_write 1685864414524425811
```

## 总结

- 构建了 CPU 周期与纳秒双重维度的性能测量系统,并讨论了测量开销、平台差异与环境调优等现实问题。
- 在交易所端(市场数据发布者、订单服务器、撮合引擎、FIFOSequencer、MEOrderBook)系统性加入 RDTSC 与时间戳插桩。
- 在交易客户端端(市场数据消费者、订单网关、交易引擎及子组件、算法模块)部署同样的测量机制,确保端到端路径可观测。
- 通过运行脚本验证,日志中出现新的 `RDTSC` 与 `TTT` 记录,为后续性能分析提供数据基础。


在本章中，我们将添加一个系统来测量本书目前所构建的C++组件的性能。我们将测量第2部分构建的交易平台系统中的延迟，以及上一节构建的客户端交易系统中的延迟。最后，我们将通过运行上一节构建的不同算法，来测量和分析端到端系统的性能。在本章中，我们将涵盖以下主题：

添加检测工具系统以测量系统性能
测量交易平台中的延迟
测量交易引擎中的延迟
使用新的检测工具系统运行整个生态系统
技术要求
本章的源代码位于仓库中的Chapter11目录下。

本章内容在很大程度上依赖前面的章节，因为我们要测量电子交易生态系统中所有不同组件和子组件的性能。因此，我们希望你熟悉目前构建的代码库，特别是“构建C++匹配引擎”“与市场参与者通信”“用C++处理市场数据并向交易平台发送订单”“构建C++交易算法基础模块”以及“构建C++做市和流动性获取算法”这几章。

本书源代码的开发环境配置如下。我们给出这些环境细节，是因为本书中的所有C++代码不一定具有可移植性，可能需要做一些小的改动才能在你的环境中运行：

操作系统（OS）：Linux 5.19.0 - 41 - generic #42~22.04.1 - Ubuntu SMP PREEMPT_DYNAMIC Tue Apr 18 17:40:00 UTC 2 x86_64 x86_64 x86_64 GNU/Linux
GCC：g++ (Ubuntu 11.3.0 - 1ubuntu1~22.04.1) 11.3.0
CMake：cmake version 3.23.2
Ninja：1.10.2
添加检测工具系统以测量系统性能
我们首先要完成的任务是添加一些实用方法，这些方法将作为我们性能测量系统的基础。它们用于测量在同一服务器上运行的进程中内部组件和子组件的延迟，也用于测量不同组件之间的延迟（在实际情况中，这些组件不太可能在同一服务器上，例如交易平台和交易客户端通常位于不同服务器上。不过，在本书中，为简单起见，我们在同一服务器上运行交易平台和交易客户端）。现在，让我们在下一节开始添加这些实用工具。

添加使用RDTSC进行性能测量的实用工具
我们添加的第一个性能测量实用工具并不直接测量时间，而是测量代码中两个点之间经过的CPU时钟周期数。这通过读取时间戳计数器（Time Stamp Counter，TSC）的值来实现，TSC是一个64位寄存器，其中包含CPU周期数。我们将执行一条汇编指令rdtsc来获取并返回该值，它会以两个32位值的形式返回，我们将把这两个值转换为一个64位值。如果我们并不关心将这些rdtsc值转换为时间单位，那么可以直接使用它们来测量/比较性能。另一种选择是将这个rdtsc值转换为时间单位，方法是将该值除以系统的时钟频率（系统时钟频率以每秒的CPU时钟周期数来指定）。例如，在我的系统上，CPU时钟频率约为2.6GHz，如下所示：


root@mydevserver:~/Building-Low-Latency-Applications-with-CPP/Chapter11$ cat /proc/cpuinfo | grep MHz
cpu MHz         : 2645.048
cpu MHz         : 2645.035
cpu MHz         : 2645.033
cpu MHz         : 2645.050
这意味着，如果我们在执行一个代码块前后测量rdtsc值，且两者之差为26个时钟周期，在我的系统上，这大约相当于26÷2.6 = 10纳秒的执行时间。我们将在本节最后一小节“理解实际测量系统中的一些问题”中对此进行更多讨论。事不宜迟，让我们看看这个测量实现的代码。本节所有代码都可以在Chapter11/common/perf_utils.h源文件中找到。

首先，我们实现一个rdtsc() C++方法，该方法在内部调用rdtsc汇编指令，并为其提供两个变量lo和hi，用于读取构成最终rdtsc值的低32位和高32位。asm指令告诉编译器，它后面的内容是一条汇编指令。volatile指令用于防止编译器优化这些指令，确保每次调用时都按原样执行，以保证我们读取TSC寄存器的值。我们将输出保存到lo和hi变量中，最后使用位运算将它们组合成一个64位值并返回：


#pragma once
namespace Common {
inline auto rdtsc() noexcept {
    unsigned int lo, hi;
    asm volatile ("rdtsc" : "=a" (lo), "=d" (hi));
    return ((uint64_t) hi << 32) | lo;
}
}
接下来，我们定义一个简单的预处理宏START_MEASURE，它接受一个名为TAG的参数，其作用是创建一个以此命名的变量，并将我们刚刚构建的rdtsc()方法的值保存到该变量中。换句话说，这个宏只是用提供的名称创建一个变量，并将rdtsc()的值保存到其中：


#define START_MEASURE(TAG) const auto TAG = Common::rdtsc()
我们定义另一个配套的宏END_MEASURE，它也接受一个名为TAG的参数以及一个名为LOGGER的参数，我们期望LOGGER是Common::Logger类型。它使用我们之前构建的rdtsc()方法进行另一次测量，并使用LOGGER对象记录两次测量值之间的差值。这段代码块被包含在do {} while(false)循环中（没有终止分号），只是为了确保在调用此方法时，如果缺少分号，编译器能够捕获到错误。也就是说，END_MEASURE(example, logger_);是有效的使用方式，而END_MEASURE(example, logger_)（缺少分号）会导致编译错误，这样做是为了与START_MEASURE保持一致。这并非绝对必要，只是我们的个人偏好：


#define END_MEASURE(TAG, LOGGER) \
do { \
    const auto end = Common::rdtsc(); \
    LOGGER.log("% RDTSC "#TAG" %\n",
        Common::getCurrentTimeStr(&time_str_), (end - TAG)); \
} while(false)
最后，我们定义一个类似的宏TTT_MEASURE，它接受类似的参数（即TAG和LOGGER）。这个宏只是记录当前时间的纳秒数，它通过调用我们之前见过的Common::getCurrentNanos()方法来获取：


#define TTT_MEASURE(TAG, LOGGER) \
do { \
    const auto TAG = Common::getCurrentNanos(); \
    LOGGER.log("% TTT "#TAG" %\n", Common::getCurrentTimeStr(&time_str_), TAG); \
} while(false)
我们将在本章中使用这些宏，但在此之前，我们需要对之前构建且已多次使用的时间实用工具做一些小改动。

更新我们之前的时间实用工具
在本节中，我们将对时间实用工具Common::getCurrentTimeStr()方法做一个小改动，使其输出更具信息性和粒度。我们的目标是将之前的输出格式：


onMarketUpdate() Sat Jun  3 09:46:34 2023 MEMarketUpdate
改为以下格式，去掉输出中的日期和年份，并将时间输出从仅显示秒改为显示秒和纳秒，以增加粒度：


onMarketUpdate() 09:46:34.645778416 MEMarketUpdate
这将帮助我们更细致地检查、排序和分析在同一秒内发生的事件。这些改动可以在Chapter11/common/time_utils.h源文件中找到。

请注意，另一个改动是包含了perf_utils.h头文件，其中包含我们在上一节构建的测量方法：


#include "perf_utils.h"
我们在“构建低延迟应用的C++基础模块”一章的“设计时间实用方法”部分见过类似的内容。我们调用std::chrono::system_clock::now()来提取当前的time_point值，并将其保存到clock变量中。我们还使用std::chrono::system_clock::to_time_t()方法从中提取并保存time_t对象到time变量中，如下所示：


namespace Common {
inline auto& getCurrentTimeStr(std::string* time_str) {
    const auto clock = std::chrono::system_clock::now();
    const auto time = std::chrono::system_clock::to_time_t(clock);
我们结合使用sprintf()、ctime()以及之前见过的std::chrono::duration_cast<std::chrono::nanoseconds>(clock.time_since_epoch()).count()方法，以HH:MM:SS.nnnnnnnnn格式提取并格式化当前时间。最后，我们将其赋值给作为参数传入此方法的std::string类型的time_str对象，并返回该对象：


char nanos_str[24];
sprintf(nanos_str, "%.8s.%09ld", ctime(&time) + 11,
    std::chrono::duration_cast<std::chrono::nanoseconds>
    (clock.time_since_epoch()).count() % NANOS_TO_SECS);
time_str->assign(nanos_str);
return *time_str;
}
}
在继续使用这些新方法之前，我们将讨论一些关于实际性能测量的要点。

理解实际测量系统存在的一些问题
在本节中，我们将讨论在实际测量性能时需要考虑的几个重要因素。理解这些内容很重要，因为性能测量并不总是像看起来那么简单，它要求你了解一些细微之处。

测量工具带来的额外开销
在实际测量性能时，我们要强调的第一个关键点是，测量系统本身并非零延迟，这一点很重要。这意味着在关键代码路径中添加测量工具会增加一些额外延迟。确保测量系统/例程相对于被测量系统的延迟极低至关重要。举个假设的例子，如果我们要测量的操作耗时几微秒，那么我们需要确保测量例程的耗时只有几纳秒，这样才不会增加过多开销。我们选择使用rdtsc()来测量性能的原因之一，就是它比调用std::chrono::system_clock::now()或clock_gettime()等函数快得多。如果要测量的代码块延迟极低，使用rdtsc()可以将额外开销降到最低。

理解RDTSC的局限性和可靠性
第二个关键点与rdtsc()有关，它并不总是具有很好的可移植性，而且在不同平台上可能存在可靠性问题。在将rdtsc()转换为时间单位时，另一个需要考虑的因素是，系统中不同核心的CPU时钟频率可能不同，使用固定的CPU时钟频率进行转换并不总是准确的。

搭建正确的测量环境
关于在交易服务器上测量性能的第三点是，为了实现准确测量，需要进行大量的调整。这涉及到一些技术，如禁用中断、确保没有不必要的进程在运行、确保非统一内存访问（NUMA，Non-Uniform Memory Access ）设置正确、调整CPU电源设置、设置CPU隔离、将线程固定到特定核心等等。在本书中讨论电子交易中所有这些需要考虑的因素超出了范围，也不是本书的重点。我们只是想指出，在进行性能测量时还有其他需要考虑的因素。感兴趣的读者可以参考《开发高频交易系统：学习如何用C++或Java基础从零实现高频交易》这本书，其中讨论了高频电子交易（HFT，High-Frequency Trading ）中特定的注意事项。

现在，我们可以将本节构建的性能测量系统应用到电子交易生态系统中，下一节将从交易所开始介绍。

测量交易所的延迟
首先，我们要在电子交易交易所的组件（市场数据发布者、匹配引擎和订单服务器）中添加测量工具。我们测量性能的方法有两种；在看代码之前，先来了解一下这两种方法。

理解如何进行内部测量

第一种方法是测量内部组件的延迟，例如，调用Exchange::MatchingEngine::processClientRequest()方法需要多长时间，或者调用Exchange::MEOrderBook::add()方法需要多长时间？对于这些情况，我们将使用一对START_MEASURE()和END_MEASURE()宏，这两个宏又会使用rdtsc()方法来测量每次调用的性能。这里没有什么阻止我们用TTT_MEASURE()宏替代rdtsc()或作为补充。但为了展示如何使用两种不同的测量系统，我们将在这些测量中使用rdtsc()。此外，我们基于这样的考虑：调用像前面提到的这类函数应该非常快，使用开销更低的rdtsc()方法可能更合适。接下来列出我们将进行的内部测量的完整列表，但感兴趣的读者可以根据需要使用类似的技术添加更多测量点。我们很快会看到如何测量这些常见方法的代码，目前在交易所一侧我们要测量的方法如下：

Common::McastSocket::send()
Exchange::MEOrderBook::add()
Exchange::MEOrderBook::cancel()
Exchange::MatchingEngine::processClientRequest()
Exchange::MEOrderBook::removeOrder()
Exchange::MEOrderBook::match()
Exchange::MEOrderBook::match()
Exchange::MEOrderBook::checkForMatch()
Exchange::MEOrderBook::addOrder()
Exchange::MEOrderBook::removeOrder()
Common::TCPSocket::send()
Exchange::FIFOSequencer::addClientRequest()
Exchange::FIFOSequencer::sequenceAndPublish()
接下来，我们退一步，了解一下在电子交易交易所中我们将对哪些高层次的节点/环节进行时间戳标记。

理解交易所的关键环节
除了测量内部组件的功能，交易所还可以记录性能数据，尤其是时间戳，来跟踪事件（客户请求）如何在不同组件和子组件之间传播。这意味着跟踪并经常发布一些指标，比如订单何时到达订单服务器、何时到达匹配引擎、对该请求的响应何时离开订单服务器、与该请求对应的市场更新何时离开市场数据发布者等等。通过记录这些指标，交易所可以了解和研究在不同市场/负载条件下的性能，跟踪每个参与者的表现等等。通过将这些指标发布给市场参与者，参与者可以了解和研究自身的表现，并思考改进的方法。

在我们的电子交易交易所中，我们将对以下事件进行时间戳标记：

T1_OrderServer_TCP_read——订单服务器（OrderServer）的TCP套接字首次读取客户请求的时间。
T2_OrderServer_LFQueue_write——客户请求写入连接到匹配引擎（MatchingEngine）的无锁队列（LFQueue）的时间。
T3_MatchingEngine_LFQueue_read——匹配引擎从无锁队列读取客户请求的时间。
T4_MatchingEngine_LFQueue_write——市场更新写入连接到市场数据发布者（MarketDataPublisher）的无锁队列的时间。
T4t_MatchingEngine_LFQueue_write——客户响应写入连接到订单服务器的无锁队列的时间。
T5_MarketDataPublisher_LFQueue_read——市场数据发布者从无锁队列读取市场更新的时间。
T5t_OrderServer_LFQueue_read——订单服务器从无锁队列读取客户响应的时间。
T6_MarketDataPublisher_UDP_write——市场更新写入市场数据发布者的UDP套接字的时间。
T6t_OrderServer_TCP_write——客户响应写入订单服务器的TCP套接字的时间。
这些时间戳的具体位置如下图所示：

img

图11.1 带有时间戳关键环节的电子交易交易所拓扑结构

现在，从下一节开始，我们可以看看为实现这两种测量方式需要进行的代码更改。

测量市场数据发布者内部的延迟
首先，我们要在市场数据发布者中添加性能测量和时间戳代码。为简洁起见，我们只展示进行这些更改的代码块，而不是包含整个源文件的源代码，对于较大的代码块也不会展示完整代码。所有更改以及与市场数据发布者相关更改的完整更新源代码，都在Chapter11/exchange/market_data/market_data_publisher.cpp源文件中。

首先，在MarketDataPublisher::run()方法中，在从outgoing_md_updates_无锁队列读取数据之后，我们使用TTT_MEASURE宏和T5_MarketDataPublisher_LFQueue_read标记添加一个时间戳，如下所示：


auto MarketDataPublisher::run() noexcept -> void {
  ...
    while (run_) {
        for (auto market_update = outgoing_md_updates_->getNextToRead();
             outgoing_md_updates_->size() && market_update;
             market_update = outgoing_md_updates_->getNextToRead()) {
            TTT_MEASURE(T5_MarketDataPublisher_LFQueue_read, logger_);
接下来，我们使用START_MEASURE和END_MEASURE宏以及Exchange_McastSocket_send标记，测量调用MCastSocket::send()方法向incremental_socket_发送数据所需的时间：


START_MEASURE(Exchange_McastSocket_send);
incremental_socket_.send(&next_inc_seq_num_, sizeof(next_inc_seq_num_));
incremental_socket_.send(market_update, sizeof(MEMarketUpdate));
END_MEASURE(Exchange_McastSocket_send, logger_);
最后，在套接字写入完成后，我们使用TTT_MEASURE宏和T6_MarketDataPublisher_UDP_write标记再添加一个时间戳：


outgoing_md_updates_->updateReadIndex();
TTT_MEASURE(T6_MarketDataPublisher_UDP_write, logger_);
...
接下来，让我们看看订单服务器组件在性能测量和时间戳方面的更改。

测量订单服务器内部的延迟
所有与性能测量和时间戳相关的更改，以及OrderServer的完整源代码，都在Chapter11/exchange/order_server/order_server.h源文件中。和之前一样，为简洁起见并避免重复，我们仅展示进行了更改的最小代码块。

首先，我们对OrderServer::run()方法进行更改，在从outgoing_responses_无锁队列（LFQueue，Lock-Free Queue）读取一个条目之后添加代码。我们使用TTT_MEASURE宏，并加上T5t_OrderServer_LFQueue_read标签，如下所示：


auto run() noexcept {
    // ...
    while (run_) {
        // ...
        for (auto client_response = outgoing_responses_->getNextToRead(); outgoing_responses_->size() && client_response; client_response = outgoing_responses_->getNextToRead()) {
            TTT_MEASURE(T5t_OrderServer_LFQueue_read, logger_);
接下来，我们使用START_MEASURE和END_MEASURE宏以及Exchange_TCPSocket_send标签来测量对TCPSocket::send()方法的调用。请注意，我们测量的是发送完整客户端响应消息的调用，在我们的实现中，这会导致两次调用TCPSocket::send()方法：


START_MEASURE(Exchange_TCPSocket_send);
cid_tcp_socket_[client_response->client_id_]->send(&next_outgoing_seq_num, sizeof(next_outgoing_seq_num));
cid_tcp_socket_[client_response->client_id_]->send(client_response, sizeof(MEClientResponse));
END_MEASURE(Exchange_TCPSocket_send, logger_);
最后，在TCP套接字发送操作完成后，我们使用TTT_MEASURE方法和T6t_OrderServer_TCP_write标签再次获取时间戳：


outgoing_responses_->updateReadIndex();
TTT_MEASURE(T6t_OrderServer_TCP_write, logger_);
// ...
接下来的一组更改在OrderServer::recvCallback()方法中。我们一进入该方法，就使用TTT_MEASURE宏和T1_OrderServer_TCP_read标签获取时间戳：


auto recvCallback(TCPSocket *socket, Nanos rx_time) noexcept {
    TTT_MEASURE(T1_OrderServer_TCP_read, logger_);
    // ...
最后，在该方法末尾，我们使用START_MEASURE和END_MEASURE宏以及Exchange_FIFOSequencer_addClientRequest标签，来测量对FIFOSequencer::addClientRequest()的调用：


START_MEASURE(Exchange_FIFOSequencer_addClientRequest);
fifo_sequencer_.addClientRequest(rx_time, request->me_client_request_);
END_MEASURE(Exchange_FIFOSequencer_addClientRequest, logger_);
// ...
最后，对于OrderServer，我们需要更新OrderServer::recvFinishedCallback()方法。我们使用START_MEASURE和END_MEASURE宏以及Exchange_FIFOSequencer_sequenceAndPublish标签，来测量对FIFOSequencer::sequenceAndPublish()方法的调用：


auto recvFinishedCallback() noexcept {
    START_MEASURE(Exchange_FIFOSequencer_sequenceAndPublish);
    fifo_sequencer_.sequenceAndPublish();
    END_MEASURE(Exchange_FIFOSequencer_sequenceAndPublish, logger_);
}
在下一小节中，我们将为FIFOSequencer子组件添加检测工具。

测量FIFOSequencer内部的延迟
所有检测工具相关的更改，以及FIFOSequencer子组件完整的更新源代码，都可以在Chapter11/exchange/order_server/fifo_sequencer.h源文件中找到。我们仅在FIFOSequencer::sequenceAndPublish()方法中进行更改。在这里，我们所做的只是在将客户端请求写入incoming_requests_无锁队列之后添加一个时间戳，通过使用TTT_MEASURE宏并赋予T2_OrderServer_LFQueue_write标签值来实现，如下所示：


auto sequenceAndPublish() {
    for (size_t i = 0; i < pending_size_; ++i) {
        // ...
        auto next_write = incoming_requests_->getNextToWriteTo();
        *next_write = std::move(client_request.request_);
        incoming_requests_->updateWriteIndex();
        TTT_MEASURE(T2_OrderServer_LFQueue_write, (*logger_));
        // ...
接下来，我们要为核心撮合引擎组件及其子组件添加检测工具和时间戳。

测量撮合引擎和订单簿内部的延迟
首先，我们将更新MatchingEngine；所有更改和MatchingEngine完整的更新源代码可在Chapter11/exchange/matcher/matching_engine.h源文件中找到。

在MatchingEngine::processClientRequest()方法中，我们将测量MEOrderBook::add()和MEOrderBook::cancel()方法所花费的时间。首先，我们展示使用START_MEASURE和END_MEASURE宏以及Exchange_MEOrderBook_add标签对MEOrderBook::add()方法所做的更改：


auto processClientRequest(const MEClientRequest *client_request) noexcept {
    // ...
    switch (client_request->type_) {
    case ClientRequestType::NEW: {
        START_MEASURE(Exchange_MEOrderBook_add);
        order_book->add(client_request->client_id_, client_request->order_id_, client_request->ticker_id_,
                        client_request->side_, client_request->price_, client_request->qty_);
        END_MEASURE(Exchange_MEOrderBook_add, logger_);
        // ...
然后，我们使用START_MEASURE和END_MEASURE宏以及Exchange_MEOrderBook_cancel标签，对MEOrderBook::cancel()方法进行更改，如下所示：


case ClientRequestType::CANCEL: {
    START_MEASURE(Exchange_MEOrderBook_cancel);
    order_book->cancel(client_request->client_id_, client_request->order_id_, client_request->ticker_id_);
    END_MEASURE(Exchange_MEOrderBook_cancel, logger_);
    // ...
我们需要更新的下一个方法是MatchingEngine::sendClientResponse()。在将客户端响应写入outgoing_ogw_responses_无锁队列之后，我们使用TTT_MEASURE宏和T4t_MatchingEngine_LFQueue_write标签，如下所示：


auto sendClientResponse(const MEClientResponse *client_response) noexcept {
    // ...
    auto next_write = outgoing_ogw_responses_->getNextToWriteTo();
    *next_write = std::move(*client_response);
    outgoing_ogw_responses_->updateWriteIndex();
    TTT_MEASURE(T4t_MatchingEngine_LFQueue_write, logger_);
}
我们还需要更新MatchingEngine::sendMarketUpdate()方法，在将市场更新写入outgoing_md_updates_无锁队列之后，使用TTT_MEASURE宏和T4_MatchingEngine_LFQueue_write标签添加时间戳：


auto sendMarketUpdate(const MEMarketUpdate *market_update) noexcept {
    // ...
    auto next_write = outgoing_md_updates_->getNextToWriteTo();
    *next_write = *market_update;
    outgoing_md_updates_->updateWriteIndex();
    TTT_MEASURE(T4_MatchingEngine_LFQueue_write, logger_);
}
我们需要在MatchingEngine中更新的最后一个方法是run()方法本身。在从incoming_requests_无锁队列读取数据之后，我们使用TTT_MEASURE宏和T3_MatchingEngine_LFQueue_read标签获取时间戳，如下所示：


auto run() noexcept {
    while (run_) {
        const auto me_client_request = incoming_requests_->getNextToRead();
        if (LIKELY(me_client_request)) {
            TTT_MEASURE(T3_MatchingEngine_LFQueue_read, logger_);
并且我们使用START_MEASURE和END_MEASURE宏以及Exchange_MatchingEngine_processClientRequest标签，来测量对MatchingEngine::processClientRequest()方法的调用：


START_MEASURE(Exchange_MatchingEngine_processClientRequest);
processClientRequest(me_client_request);
END_MEASURE(Exchange_MatchingEngine_processClientRequest, logger_);
// ...
我们需要更新的交易所端的最后一个组件是MatchingEngine中的MEOrderBook子组件。

测量MEOrderBook内部的延迟
在本小节中，我们将讨论对MEOrderBook组件进行的检测工具相关更改，这些更改可在Chapter11/exchange/matcher/me_order_book.cpp源文件中找到。

我们首先要更新的方法是MEOrderBook::match()。我们希望使用START_MEASURE和END_MEASURE宏以及Exchange_MEOrderBook_removeOrder标签，来测量对MEOrderBook::removeOrder()的调用，如下所示：


auto MEOrderBook::match(TickerId ticker_id, ClientId client_id, Side side, OrderId client_order_id, OrderId new_market_order_id, MEOrder* itr, Qty* leaves_qty) noexcept {
    // ...
    if (!order->qty_) {
        // ...
        START_MEASURE(Exchange_MEOrderBook_removeOrder);
        removeOrder(order);
        END_MEASURE(Exchange_MEOrderBook_removeOrder, (*logger_));
        // ...
我们还需要更新MEOrderBook::checkForMatch()方法，以测量对MEOrderBook::match()的调用。对于两个执行分支，我们使用START_MEASURE和END_MEASURE宏以及Exchange_MEOrderBook_match标签，如下所示：


auto MEOrderBook::checkForMatch(ClientId client_id, OrderId client_order_id, TickerId ticker_id, Side side, Price price, Qty qty, Qty new_market_order_id) noexcept {
    // ...
    if (side == Side::BUY) {
        while (leaves_qty && asks_by_price_) {
            // ...
            START_MEASURE(Exchange_MEOrderBook_match);
            match(ticker_id, client_id, side, client_order_id, new_market_order_id, ask_itr, &leaves_qty);
            END_MEASURE(Exchange_MEOrderBook_match, (*logger_));
        }
    }
    if (side == Side::SELL) {
        while (leaves_qty && bids_by_price_) {
            // ...
            START_MEASURE(Exchange_MEOrderBook_match);
            match(ticker_id, client_id, side, client_order_id, new_market_order_id, bid_itr, &leaves_qty);
            END_MEASURE(Exchange_MEOrderBook_match, (*logger_));
        }
    }
    // ...
我们将在MEOrderBook::add()方法中添加更多检测代码，以测量几个不同的调用。第一个是对MEOrderBook::checkForMatch()的调用，我们将使用Exchange_MEOrderBook_checkForMatch标签：


auto MEOrderBook::add(ClientId client_id, OrderId client_order_id, TickerId ticker_id, Side side, Price price, Qty qty) noexcept -> void {
    // ...
    START_MEASURE(Exchange_MEOrderBook_checkForMatch);
    const auto leaves_qty = checkForMatch(client_id, client_order_id, ticker_id, side, price, qty, new_market_order_id);
    END_MEASURE(Exchange_MEOrderBook_checkForMatch, (*logger_));
    // …
接下来是对MEOrderBook::addOrder()的调用，对此我们将使用Exchange_MEOrderBook_addOrder标签：


START_MEASURE(Exchange_MEOrderBook_addOrder);
addOrder(order);
END_MEASURE(Exchange_MEOrderBook_addOrder, (*logger_));
我们需要添加更细致检测代码的MEOrderBook的最后一个方法是cancel()方法。在这个方法中，我们想要测量对MEOrderBook::removeOrder()方法的调用，如下所示，使用START_MEASURE和END_MEASURE宏以及Exchange_MEOrderBook_removeOrder标签：


auto MEOrderBook::cancel(ClientId client_id, OrderId order_id, TickerId ticker_id) noexcept -> void {
...
START_MEASURE(Exchange_MEOrderBook_removeOrder);
removeOrder(exchange_order);
END_MEASURE(Exchange_MEOrderBook_removeOrder, (*logger_));
...
至此，我们完成了想要在电子交易所端添加的所有测量，在下一节中，我们将在另一端，即交易客户端系统，添加类似的检测代码。

测量交易引擎中的延迟
在本节中，我们将重点为交易客户端系统（市场数据消费者、订单网关、交易引擎及其子组件）添加性能测量和时间戳。在这里，我们同样会测量内部组件的性能，并添加时间戳，以便对传入和传出事件的延迟进行更高级别的分析。

理解内部测量方法
测量交易客户端系统内部组件性能的动机和方法与交易所端相同。下面列出了我们将进行的完整内部测量列表，但感兴趣的读者可以根据实际情况使用类似的技术添加更多测量点。我们很快就会看到如何测量这些熟悉方法的代码，目前，我们将在客户端测量的方法如下：

Trading::MarketDataConsumer::recvCallback()
Common::TCPSocket::send()
Trading::OrderGateway::recvCallback()
Trading::OrderManager::moveOrders()
Trading::OrderManager::onOrderUpdate()
Trading::OrderManager::moveOrders()
Trading::OrderManager::onOrderUpdate()
Trading::MarketOrderBook::addOrder()
Trading::MarketOrderBook::removeOrder()
Trading::MarketOrderBook::updateBBO()
Trading::OrderManager::cancelOrder()
Trading::RiskManager::checkPreTradeRisk()
Trading::OrderManager::newOrder()
Trading::OrderManager::moveOrder()
Trading::OrderManager::moveOrder()
Trading::PositionKeeper::updateBBO()
Trading::FeatureEngine::onOrderBookUpdate()
Trading::TradeEngine::algoOnOrderBookUpdate()
Trading::FeatureEngine::onTradeUpdate()
Trading::TradeEngine::algoOnTradeUpdate()
Trading::PositionKeeper::addFill()
Trading::TradeEngine::algoOnOrderUpdate()
与电子交易交易所的情况一样，我们需要了解在交易客户端系统中要添加时间戳的关键节点。

理解交易客户端系统中的关键节点
市场参与者为事件在各个组件和子组件中的流动添加时间戳，原因与交易所类似。通过记录和分析这些事件的时间，参与者可以寻求改进他们的系统，并分析如何提高盈利能力。

在我们的电子交易客户端系统中，我们将对以下事件进行时间戳记录：

T7_MarketDataConsumer_UDP_read——市场数据消费者（MarketDataConsumer）从UDP套接字读取市场数据更新的时间。
T7t_OrderGateway_TCP_read——订单网关（OrderGateway）从TCP套接字读取客户端响应的时间。
T8_MarketDataConsumer_LFQueue_write——市场数据更新被写入连接到交易引擎（TradeEngine）的无锁队列（LFQueue）的时间。
T8t_OrderGateway_LFQueue_write——客户端响应被写入连接到交易引擎的无锁队列的时间。
T9_TradeEngine_LFQueue_read——交易引擎从市场数据消费者的无锁队列读取市场数据更新的时间。
T9t_TradeEngine_LFQueue_read——交易引擎从订单网关的无锁队列读取客户端响应的时间。
T10_TradeEngine_LFQueue_write——客户端请求被写入连接到订单网关的无锁队列的时间。
T11_OrderGateway_LFQueue_read——订单网关从交易引擎的无锁队列读取客户端请求的时间。
T12_OrderGateway_TCP_write——订单网关将客户端请求写入TCP套接字的时间。
这些时间戳的确切位置如下图所示：

带有时间戳关键节点的电子交易客户端系统拓扑

图11.2——带有时间戳关键节点的电子交易客户端系统拓扑

从下一节开始，我们可以着手查看为实现这两种测量形式所需进行的代码更改。

测量市场数据消费者内部的延迟
我们将从市场数据消费者组件开始，如之前所讨论的，这里我们只展示代码的更改部分，不再重复完整的源代码。这些更改以及完整的源代码都在Chapter11/trading/market_data/market_data_consumer.cpp源文件中。

我们获取的第一个时间戳是在进入MarketDataConsumer::recvCallback()方法时，使用TTT_MEASURE宏和T7_MarketDataConsumer_UDP_read标签：


auto MarketDataConsumer::recvCallback(McastSocket *socket) noexcept -> void {
    TTT_MEASURE(T7_MarketDataConsumer_UDP_read, logger_);
我们还将使用START_MEASURE和END_MEASURE宏，以及Trading_MarketDataConsumer_recvCallback标签，将整个方法括起来，以测量整个方法的延迟：


START_MEASURE(Trading_MarketDataConsumer_recvCallback);
...
END_MEASURE(Trading_MarketDataConsumer_recvCallback, logger_);
}
在将解码后的市场更新写入incoming_md_updates_无锁队列之后，我们将使用TTT_MEASURE宏和T8_MarketDataConsumer_LFQueue_write标签添加一个时间戳：


auto next_write = incoming_md_updates_->getNextToWriteTo();
*next_write = std::move(request->me_market_update_);
incoming_md_updates_->updateWriteIndex();
TTT_MEASURE(T8_MarketDataConsumer_LFQueue_write, logger_);
在下一节中，我们将继续为订单网关组件添加性能测量。

测量订单网关内部的延迟
在本小节中，我们将更新订单网关组件；所有的更改和更新后的完整源代码都在Chapter11/trading/order_gw/order_gateway.cpp源文件中。

我们要更新的第一个方法是OrderGateway::run()方法，我们获取的第一个时间戳是从outgoing_requests_无锁队列读取客户端请求的时候。我们使用TTT_MEASURE宏和T11_OrderGateway_LFQueue_read标签来实现：


auto OrderGateway::run() noexcept -> void {
...
for (auto client_request = outgoing_requests_->getNextToRead(); client_request; client_request = outgoing_requests_->getNextToRead()) {
    TTT_MEASURE(T11_OrderGateway_LFQueue_read, logger_);
接下来我们要测量的是执行Common::TCPSocket::send()方法所需的时间，如下所示，我们使用Trading_TCPSocket_send标签来实现：


START_MEASURE(Trading_TCPSocket_send);
tcp_socket_.send(&next_outgoing_seq_num_, sizeof(next_outgoing_seq_num_));
tcp_socket_.send(client_request, sizeof(Exchange::MEClientRequest));
END_MEASURE(Trading_TCPSocket_send, logger_);
最后，在TCPSocket::send()方法完成后，我们也使用TTT_MEASURE宏和T12_OrderGateway_TCP_write标签添加时间戳：


outgoing_requests_->updateReadIndex();
TTT_MEASURE(T12_OrderGateway_TCP_write, logger_);
我们要在订单网关组件中更新的下一个方法是recvCallback()方法。在进入recvCallback()方法时，我们使用TTT_MEASURE宏和T7t_OrderGateway_TCP_read标签获取一个时间戳：


auto OrderGateway::recvCallback(TCPSocket *socket, Nanos rx_time) noexcept -> void {
    TTT_MEASURE(T7t_OrderGateway_TCP_read, logger_);
与MarketDataConsumer::recvCallback()方法一样，我们将使用START_MEASURE和END_MEASURE宏，以及Trading_OrderGateway_recvCallback标签，将整个OrderGateway::recvCallback()方法括起来：


START_MEASURE(Trading_OrderGateway_recvCallback);
...
END_MEASURE(Trading_OrderGateway_recvCallback, logger_);
}
在将客户端响应写入incoming_responses_无锁队列之后，我们同样使用TTT_MEASURE宏和T8t_OrderGateway_LFQueue_write标签获取一个时间戳：


auto next_write = incoming_responses_->getNextToWriteTo();
*next_write = std::move(response->me_client_response_);
incoming_responses_->updateWriteIndex();
TTT_MEASURE(T8t_OrderGateway_LFQueue_write, logger_);
在本节的最后一个小节中，我们将为交易引擎及其所有子组件添加检测代码。

测量交易引擎内部的延迟
首先，我们从更新TradeEngine类本身开始，相关更改及完整的更新源代码可在Chapter11/trading/strategy/trade_engine.cpp源文件中找到。

我们首先关注TradeEngine::sendClientRequest()方法，在这里，我们将MEClientRequest写入outgoing_ogw_requests_无锁队列后，使用T10_TradeEngine_LFQueue_write标签记录一个时间戳：


auto TradeEngine::sendClientRequest(const Exchange::MEClientRequest *client_request) noexcept -> void {
    auto next_write = outgoing_ogw_requests_->getNextToWriteTo();
    *next_write = std::move(*client_request);
    outgoing_ogw_requests_->updateWriteIndex();
    TTT_MEASURE(T10_TradeEngine_LFQueue_write, logger_);
接下来是TradeEngine::run()方法，首要任务是在从incoming_ogw_responses_无锁队列读取客户响应后，使用TTT_MEASURE宏和T9t_TradeEngine_LFQueue_read标签记录时间戳：


auto TradeEngine::run() noexcept -> void {
    while (run_) {
        for (auto client_response = incoming_ogw_responses_->getNextToRead(); client_response; client_response = incoming_ogw_responses_->getNextToRead()) {
            TTT_MEASURE(T9t_TradeEngine_LFQueue_read, logger_);
我们还会在从incoming_md_updates_无锁队列读取市场更新后，使用T9_TradeEngine_LFQueue_read标签记录时间戳：


        for (auto market_update = incoming_md_updates_->getNextToRead(); market_update; market_update = incoming_md_updates_->getNextToRead()) {
            TTT_MEASURE(T9_TradeEngine_LFQueue_read, logger_);
接下来需要更新的方法是TradeEngine::onOrderBookUpdate()，我们要做的第一件事是使用START_MEASURE和END_MEASURE宏，以及Trading_PositionKeeper_updateBBO标签，测量对PositionKeeper::updateBBO()的调用：


auto TradeEngine::onOrderBookUpdate(TickerId ticker_id,
                                   Price price, Side side, MarketOrderBook *book) noexcept -> void {
   ...
    START_MEASURE(Trading_PositionKeeper_updateBBO);
    position_keeper_.updateBBO(ticker_id, bbo);
    END_MEASURE(Trading_PositionKeeper_updateBBO, logger_);
我们还需要测量对FeatureEngine::onOrderBookUpdate()方法的调用，为此我们使用Trading_FeatureEngine_onOrderBookUpdate标签：


    START_MEASURE(Trading_FeatureEngine_onOrderBookUpdate);
    feature_engine_.onOrderBookUpdate(ticker_id, price, side, book);
    END_MEASURE(Trading_FeatureEngine_onOrderBookUpdate, logger_);
我们还需要测量对TradeEngine::algoOnOrderBookUpdate_这个std::function的调用，它会在MarketMaker或LiquidityTaker算法实例中调用onOrderBookUpdate()。我们使用START_MEASURE和END_MEASURE宏，并使用Trading_TradeEngine_algoOnOrderBookUpdate_标签：


    START_MEASURE(Trading_TradeEngine_algoOnOrderBookUpdate_);
    algoOnOrderBookUpdate_(ticker_id, price, side, book);
    END_MEASURE(Trading_TradeEngine_algoOnOrderBookUpdate_, logger_);
下一个方法是TradeEngine::onTradeUpdate()。在这里，我们首先测量对FeatureEngine::onTradeUpdate()的调用，给它分配Trading_FeatureEngine_onTradeUpdate标签：


auto TradeEngine::onTradeUpdate(const Exchange::MEMarketUpdate *market_update,
                               MarketOrderBook *book) noexcept -> void {
   ...
    START_MEASURE(Trading_FeatureEngine_onTradeUpdate);
    feature_engine_.onTradeUpdate(market_update, book);
    END_MEASURE(Trading_FeatureEngine_onTradeUpdate, logger_);
我们要测量的另一个调用是使用TradeEngine::algoOnTradeUpdate_标准函数的调用，它会将调用转发到MarketMaker或LiquidityTaker实例。我们使用START_MEASURE和END_MEASURE宏，标签为Trading_TradeEngine_algoOnTradeUpdate_：


    START_MEASURE(Trading_TradeEngine_algoOnTradeUpdate_);
    algoOnTradeUpdate_(market_update, book);
    END_MEASURE(Trading_TradeEngine_algoOnTradeUpdate_, logger_);
最后一个需要添加测量工具的方法是TradeEngine::onOrderUpdate()。在这里，我们首先测量对PositionKeeper::addFill()的调用，使用Trading_PositionKeeper_addFill标签：


auto TradeEngine::onOrderUpdate(const Exchange::MEClientResponse *client_response) noexcept -> void {
    if (UNLIKELY(client_response->type_ == Exchange::ClientResponseType::FILLED)) {
        START_MEASURE(Trading_PositionKeeper_addFill);
        position_keeper_.addFill(client_response);
        END_MEASURE(Trading_PositionKeeper_addFill, logger_);
    }
最后，我们在调用algoOnOrderUpdate_这个std::function对象的周围添加START_MEASURE和END_MEASURE宏，并使用Trading_TradeEngine_algoOnOrderUpdate_标签：


    START_MEASURE(Trading_TradeEngine_algoOnOrderUpdate_);
    algoOnOrderUpdate_(client_response);
    END_MEASURE(Trading_TradeEngine_algoOnOrderUpdate_, logger_);
我们将在TradeEngine内部相互协作的每个子组件中添加一些内部测量代码，接下来从OrderManager组件开始。

测量订单管理器（OrderManager）内部的延迟
本小节重点介绍在OrderManager中添加性能测量的更改，所有代码可在Chapter11/trading/strategy/order_manager.h源文件中找到。

首先，我们在OrderManager::moveOrder()方法中添加测量。我们首先测量对OrderManager::cancelOrder()方法的调用，使用Trading_OrderManager_cancelOrder标签：


auto moveOrder(OMOrder *order, TickerId ticker_id,
               Price price, Side side, Qty qty) noexcept {
    switch (order->order_state_) {
    case OMOrderState::LIVE: {
        if (order->price_ != price) {
            START_MEASURE(Trading_OrderManager_cancelOrder);
            cancelOrder(order);
            END_MEASURE(Trading_OrderManager_cancelOrder, (*logger_));
我们还将测量对风险管理器组件的调用，具体是checkPreTradeRisk()调用。我们在风险检查周围使用START_MEASURE和END_MEASURE宏，并加上Trading_RiskManager_checkPreTradeRisk标签，如下所示：


    case OMOrderState::DEAD: {
        if (LIKELY(price != Price_INVALID)) {
            START_MEASURE(Trading_RiskManager_checkPreTradeRisk);
            const auto risk_result = risk_manager_.checkPreTradeRisk(ticker_id, side, qty);
            END_MEASURE(Trading_RiskManager_checkPreTradeRisk, (*logger_));
如果风险检查成功，另一个要测量的是对OrderManager::newOrder()的调用，我们给这个测量分配Trading_OrderManager_newOrder标签，如下所示：


        if (LIKELY(risk_result == RiskCheckResult::ALLOWED)) {
            START_MEASURE(Trading_OrderManager_newOrder);
            newOrder(order, ticker_id, price, side, qty);
            END_MEASURE(Trading_OrderManager_newOrder, (*logger_));
OrderManager中另一个要添加测量的方法是moveOrders()方法，在这个方法中，我们使用START_MEASURE和END_MEASURE以及Trading_OrderManager_moveOrder标签，将对OrderManager::moveOrder()的调用括起来：


auto moveOrders(TickerId ticker_id, Price bid_price,
                Price ask_price, Qty clip) noexcept {
   ...
    START_MEASURE(Trading_OrderManager_moveOrder);
    moveOrder(bid_order, ticker_id, bid_price, Side::BUY, clip);
    END_MEASURE(Trading_OrderManager_moveOrder, (*logger_));
   ...
    START_MEASURE(Trading_OrderManager_moveOrder);
    moveOrder(ask_order, ticker_id, ask_price, Side::SELL, clip);
    END_MEASURE(Trading_OrderManager_moveOrder, (*logger_));
TradeEngine类中接下来需要更新的子组件是MarketOrderBook。

测量市场订单簿（MarketOrderBook）内部的延迟
MarketOrderBook的更改和完整源代码可在Chapter11/trading/strategy/market_order_book.cpp源文件中找到。

首先，在MarketOrderBook::onMarketUpdate()方法中，处理MarketUpdateType::ADD消息的情况时，我们将测量对MarketOrderBook::addOrder()的调用。像往常一样，使用START_MEASURE和END_MEASURE宏，加上Trading_MarketOrderBook_addOrder标签来实现：


auto MarketOrderBook::onMarketUpdate(const Exchange::MEMarketUpdate *market_update) noexcept -> void {
   ...
    switch (market_update->type_) {
    case Exchange::MarketUpdateType::ADD: {
        auto order = order_pool_.allocate(market_update->
                                         order_id_, market_update->side_, market_update->
                                         price_,
                                         market_update->
                                         qty_,
                                         market_update->
                                         priority_, nullptr,
                                         nullptr);
        START_MEASURE(Trading_MarketOrderBook_addOrder);
        addOrder(order);
        END_MEASURE(Trading_MarketOrderBook_addOrder, (*logger_));
为了测量MarketUpdateType::CANCEL情况下对MarketOrderBook::removeOrder()的调用，我们在START_MEASURE和END_MEASURE宏中使用Trading_MarketOrderBook_removeOrder标签：


    case Exchange::MarketUpdateType::CANCEL: {
        auto order = oid_to_order_.at(market_update->order_id_);
        START_MEASURE(Trading_MarketOrderBook_removeOrder);
        removeOrder(order);
        END_MEASURE(Trading_MarketOrderBook_removeOrder, (*logger_));
最后，我们在对MarketOrderBook::updateBBO()的调用周围添加测量，并给它分配Trading_MarketOrderBook_updateBBO标签：


    START_MEASURE(Trading_MarketOrderBook_updateBBO);
    updateBBO(bid_updated, ask_updated);
    END_MEASURE(Trading_MarketOrderBook_updateBBO, (*logger_));
接下来要测量的组件是其中一个交易算法——流动性获取者（LiquidityTaker）算法。

测量流动性获取者（LiquidityTaker）算法内部的延迟
我们在这里讨论的更改以及完整的源代码都在Chapter11/trading/strategy/liquidity_taker.h源文件中。

我们的第一个测量点在LiquidityTaker类的onTradeUpdate()方法中。当信号触发一笔交易时，我们测量对OrderManager::moveOrders()的调用，并给它分配OrderManager_moveOrders标签，如下所示：


auto onTradeUpdate(const Exchange::MEMarketUpdate
                   *market_update, MarketOrderBook *book) noexcept -> void {
   ...
    if (agg_qty_ratio >= threshold) {
        START_MEASURE(OrderManager_moveOrders);
        if (market_update->side_ == Side::BUY)
            order_manager_->moveOrders(market_update->
                                       ticker_id_, bbo->ask_price_, Price_INVALID, clip);
        else
            order_manager_->moveOrders(market_update->
                                       ticker_id_, Price_INVALID, bbo->bid_price_, clip);
        END_MEASURE(OrderManager_moveOrders, (*logger_));
    }
我们想要测量的另一个调用在onOrderUpdate()方法中，使用START_MEASURE和END_MEASURE宏以及Trading_OrderManager_onOrderUpdate标签来测量对OrderManager::onOrderUpdate()的调用：


auto onOrderUpdate(const Exchange::MEClientResponse
                   *client_response) noexcept -> void {
    START_MEASURE(Trading_OrderManager_onOrderUpdate);
    order_manager_->onOrderUpdate(client_response);
    END_MEASURE(Trading_OrderManager_onOrderUpdate, (*logger_));
最后，本章我们要更新的最后一个组件是做市商（MarketMaker）算法。

测量做市商（MarketMaker）算法内部的延迟
MarketMaker的更改和完整源代码在Chapter11/trading/strategy/market_maker.h源文件中。

MarketMaker::onOrderBookUpdate()方法包含对OrderManager::moveOrders()的调用，我们在下面的代码块中使用Trading_OrderManager_moveOrders标签来测量这个调用：


auto onOrderBookUpdate(TickerId ticker_id, Price price,
                       Side side, const MarketOrderBook *book) noexcept -> void {
   ...
    START_MEASURE(Trading_OrderManager_moveOrders);
    order_manager_->moveOrders(ticker_id, bid_price, ask_price, clip);
    END_MEASURE(Trading_OrderManager_moveOrders, (*logger_));
另一个方法MarketMaker::onOrderUpdate()包含对OrderManager::onOrderUpdate()的调用，我们同样对其进行测量，并给它分配Trading_OrderManager_onOrderUpdate标签：


auto onOrderUpdate(const Exchange::MEClientResponse
                   *client_response) noexcept -> void {
   ...
    START_MEASURE(Trading_OrderManager_onOrderUpdate);
    order_manager_->onOrderUpdate(client_response);
    END_MEASURE(Trading_OrderManager_onOrderUpdate, (*logger_));
至此，我们完成了整个电子交易生态系统中所有与性能测量和时间戳相关的更改。我们将快速了解如何运行包含目前所做更改的生态系统，以及在日志文件中发现的差异。

使用新的测量系统运行整个生态系统
运行更新后的电子交易生态系统的方式和之前一样，通过运行以下脚本来启动：


root@mydevserver:~/Building-Low-Latency-Applications-with-CPP/Chapter11$ bash scripts/run_exchange_and_clients.sh
新的生态系统运行完成后，你会注意到像下面这样的用于RDTSC测量的性能测量日志条目：


root@mydevserver:~/Building-Low-Latency-Applications-with-CPP/Chapter11$ grep Exchange_MEOrderBook_match *.log
exchange_matching_engine.log:02:42:59.980424597 RDTSC Exchange_MEOrderBook_match 205247
exchange_matching_engine.log:02:43:00.022326352 RDTSC Exchange_MEOrderBook_match 216239
也有像下面这样的RDTSC测量日志条目：


root@mydevserver:~/Building-Low-Latency-Applications-with-CPP/Chapter11$ grep Trading_MarketOrderBook_addOrder *.log
trading_engine_1.log:02:44:18.894251975 RDTSC Trading_MarketOrderBook_addOrder 204
trading_engine_1.log:02:44:18.904221378 RDTSC Trading_MarketOrderBook_addOrder 971
还有像下面这样的TTT测量日志条目：


root@mydevserver:~/Building-Low-Latency-Applications-with-CPP/Chapter11$ grep T6_MarketDataPublisher_UDP_write *.log
exchange_market_data_publisher.log:02:40:13.596201293 TTT T6_MarketDataPublisher_UDP_write 1685864413596201240
exchange_market_data_publisher.log:02:40:13.624236967 TTT T6_MarketDataPublisher_UDP_write 1685864413624236907
以及像下面这样的TTT测量日志条目：


root@mydevserver:~/Building-Low-Latency-Applications-with-CPP/Chapter11$ grep T8t_OrderGateway_LFQueue_write *.log
trading_order_gateway_1.log:02:40:14.524401434 TTT T8t_OrderGateway_LFQueue_write 1685864414524401386
trading_order_gateway_1.log:02:40:14.524425862 TTT T8t_OrderGateway_LFQueue_write 1685864414524425811
我们将在下一章回顾这些性能数据，不过现在本章内容就结束了。

总结
本章完全致力于测量我们电子交易生态系统的性能。首先，我们构建了一个系统，用于测量和比较任意代码块执行所产生的延迟。我们还构建了一个系统，用于在重要事件发生时生成纳秒级的时间戳。我们也讨论了这些系统设计背后的动机，以及在使用这些性能测量技术时需要牢记的各种要点。

接下来的部分专门探讨了电子交易所端各个组件和子组件中性能测量的设计和动机。然后，我们构建并更新了交易所中的所有源代码，添加了性能测量和时间戳代码。

在完成电子交易所内性能测量的讨论和实现之后，我们在交易系统中进行了类似的测量。最后，我们通过运行这个更新后的生态系统并观察性能测量系统生成的新日志条目，结束了本章内容。
