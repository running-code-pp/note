# 迭代器简介
| 迭代器类型      | 支持操作                          | 典型容器/用途                                           |
| --------------- | --------------------------------- | ------------------------------------------------------- |
| 输入/输出迭代器 | ++, *                             | 流迭代器                                                |
| 前向迭代器      | ++, *, 可多次遍历                 | std::forward_list std::unordered_map std::unordered_set |
| 双向迭代器      | ++, --, *                         | std::list, std::set, std::map                           |
| 随机访问迭代器  | +, -, +=, -=, it1 - it2, <, >, [] | std::vector, std::deque, C数组                          |

# vector
随机访问迭代器
严格的连续存储

如果vectorpush_back了一个元素那么，可能触发vector重新扩容，那么之前所有的元素位置都改变了,这样的话就没用了,
第二种情况从vector删除一个元素,他之后的元素的迭代器会失效，因为会移动元素

- 插入元素: 如果不触发扩容，那么插入元素之后的元素的迭代器会失效
- 删除元素: 删除元素之后的元素的迭代器会失效，因为后面的元素会向前移动一个位置
- reserve: 如果出发了扩容那么所有的都会失效,这只有从小容量reserve到大容量的时候才会失效，从大容量reserve到小容量实际上不会重新分配

# list
双向迭代器

list是双向链表，元素是分散存储的，所以删除和增加对于迭代器不会失效

# deque
随机访问迭代器

并不是严格的连续存储，内部是分段的,每个块固定大小然后块之间通过指针连接

- erase之后所有的迭代器全部失效，因为可能内部要重组块，甚至重新分配块
- push_back insert 导致所有迭代器失效
是std::stack和std::queue的底层存储数据结构


# stack
随机访问迭代器
迭代器行为和deque一致

基于std::deque实现


# queue
随机访问迭代器
迭代器行为和deque一致

基于std::deque实现


# map
双向迭代器

傻逼抽根烟个插入不会影响其他迭代器，指挥影响当前元素的迭代器


底层数据结构是红黑树 std::tree

# set
双向迭代器

底层数据结构是红黑树 std::tree

# unordered_map
前向迭代器

插入元素：不会导致已有迭代器失效（除非 rehash）。
删除元素：只有指向被删除元素的迭代器失效，其他迭代器有效。
rehash（扩容）：所有迭代器都会失效，因为哈希表会重新分配桶，元素位置可能全部改变。

底层数据结构是哈希表

# unordered_set
前向迭代器

插入元素：不会导致已有迭代器失效（除非 rehash）。
删除元素：只有指向被删除元素的迭代器失效，其他迭代器有效。
rehash（扩容）：所有迭代器都会失效，因为哈希表会重新分配桶，元素位置可能全部改变。

底层数据结构是哈希表


# forward_list   
前向迭代器

删除/插入元素时，只有被操作元素的迭代器失效，其他迭代器有效

# array
随机访问迭代器

严格的连续存储

不能插入删除