<!--
 * @Author: running-code-pp 3320996652@qq.com
 * @Date: 2025-10-19 21:18:22
 * @LastEditors: running-code-pp 3320996652@qq.com
 * @LastEditTime: 2025-10-22 09:57:41
 * @FilePath: \note\cpp\语言特性\模板.md
 * @Description: 
 * @Copyright: Copyright (c) 2025 by ${git_name}, All Rights Reserved.
-->
# std::is_detected(C++17 <type_traits>)
它用于检测在给定的模板参数下，某个类型别名（或模板）是否可以被合法地实例化

简单来说，它可以回答一个问题：“如果我用这些类型去实例化这个模板（或访问这个嵌套类型），会发生编译错误吗？”

std::is_detected 本身是一个类型特征（type trait），它继承自 std::true_type 或 std::false_type，取决于检测是否成功。

# SFINAE 替换失败不是一个错误
## 定义
SFINAE: Substitution Failure Is Not An Error（替换失败不是一个错误）

发生在模板参数推导阶段
```cpp
namespace no_sfinae {
	template<typename T>
	void foo(T t1,T t2) {
		std::cout << "1" << std::endl;
	}

	template<typename T>
	void foo(T t, float a) {
		std::cout << "2" << std::endl;
	}

	void test_template_override() {
		foo<int>(1, 2);//1
		foo<int>(2, 2.56f);//2
	}
	// 这里已经指明了T为int那么就存在两个函数foo(int,int) foo(int float)，并没有出现匹配失败的情况
} // namespace no_sfinae

namespace sfinae {
	template<typename T>
	void foo(T t1, typename T::SUB_TYPE t2) {
		std::cout << "1" << std::endl;
	}

	template<typename T>
	void foo(T t1, T t2) {
		std::cout << "2" << std::endl;
	}

	void test_template_override() {
		foo(1, 2);//2
	}
	// 这里并没有指定T的类型，编译器根据1推导出T为int，尝试匹配第一个函数模板发现并不存在int::SUB_TYPE，但是并不会报错
	// 继续向下匹配foo(int,int)
}
```

# 模板特化
为模板的特定类型或类型组合提供一个定制化的、不同的实现,做到特殊情况特殊处理

```cpp
// 通用模板
template<typename T>
T max(T a, T b) {
    std::cout << "通用版本\n";
    return (a > b) ? a : b;
}

// 全特化：为 const char* 提供特殊实现
template<>
const char* max<const char*>(const char* a, const char* b) {
    std::cout << "char* 特化版本\n";
    return (std::strcmp(a, b) > 0) ? a : b; // 使用 strcmp 比较字符串内容
}
```

# 模板偏特化
模板偏特化（Partial Specialization） 是 C++ 模板机制中的一个高级特性，它允许你为类模板（不适用于函数模板）的一部分模板参数提供一个特殊的实现，而另一部分参数仍然保持通用。

你可以把它理解为“部分定制”——当模板的某些参数是特定类型时，使用一个优化或不同的实现，而其他参数仍然可以是任意类型。

为什么需要偏特化？
考虑一个通用的类模板：

```cpp
template<typename T1, typename T2>
struct MyPair {
    T1 first;
    T2 second;
    // 通用实现
};
```
这个模板对所有类型组合都有效。但有时，对于特定的参数组合，你可能想要：

优化性能：例如，当两个类型相同时，可以使用更高效的存储。
修复通用实现的问题：例如，当某个参数是指针时，需要特殊处理。
提供特定功能：例如，当第二个类型是 int 时，添加一个特殊方法。
这时，全特化（为所有参数指定具体类型，如 MyPair<int, double>）就太局限了，因为你需要为每一种组合都写一个特化。而偏特化允许你一次性处理一类情况。

偏特化的语法
```cpp
// 通用模板
template<typename T1, typename T2>
class MyClass { /* ... */ };

// 偏特化：针对部分参数
template<typename T>  // 这里只指定了一个参数（或部分参数）
class MyClass<T, int> { /* 特殊实现：当第二个类型是 int 时 */ };
```


# std::is_trivially_copyable_v(CPP17)
在编译期检查一个类型T是否是可平凡复制的,
不存在自定义的拷贝构造，移动构造，拷贝赋值运算符，移动复制运算符，虚函数，虚基类，所有非静态成员和基类都是可平凡复制的，

**可以通过简单的内存拷贝实现安全的复制**

# std::is_move_assignable_v(cpp17)

在编译期判断类型 T 是否可以通过移动赋值操作符 operator=(T&&) 进行赋值

# std::is_void 和 std::void_t 和 std::is_void_t

std::is_void是类型萃取，用来判断类型T是否是void类型(包括修饰的void类型:const void、volatile void 等)结果是一个编译器的bool值，C++11

std::is_void_v<T> 是一个变量模板:等效于 std::is_void<T>::value c++17

std::void_t<T>是一个模板工具，如果T是有效类型就折叠为void,通常用于SFINAE



std::is_
# 模板特化技巧
```cpp
template< typename T1,typename T2,bool = std::void<T2>,typename = void>
struct RetTypeCheck: public std::false_type{}
```
这里第三个模板参数不是类型参数，而是一个bool值，最后一个类型参数默认为void用来做占位符

然后我们可以特化两个版本，T2为void和T2不是void
```cpp
template< typename T1,typename T2,true,std::void_t<ResultType::type>>
struct RetTypeCheck: public std::true_type{}

template< typename T1,typename T2,false,std::void_t<ResultType::type>>
struct RetTypeCheck: public std::true_type{}
```