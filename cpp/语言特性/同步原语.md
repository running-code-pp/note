<!--
 * @Author: running-code-pp 3320996652@qq.com
 * @Date: 2025-10-20 16:32:58
 * @LastEditors: running-code-pp 3320996652@qq.com
 * @LastEditTime: 2025-10-20 16:34:08
 * @FilePath: \note\note\cpp\语言特性\同步原语.md
 * @Description: 
 * @Copyright: Copyright (c) 2025 by ${git_name}, All Rights Reserved.
-->
# scoped_lock和lock_guard的区别

| 特性 | lock_guard | scoped_lock |
|------|------------|-------------|
| 支持单个锁 | ✅ 是 | ✅ 是 |
| 支持多个锁（防死锁） | ❌ 否 | ✅ 是 |
| C++ 标准引入 | C++11 | C++17 |
| 是否可变参数模板 | ❌ 否 | ✅ 是 |
| 是否调用 std::lock() | ❌ 否 | ✅ 是（自动避免死锁） |

```cpp
std::mutex mtx1, mtx2, mtx3;

void good_example() {
    std::scoped_lock lock(mtx1, mtx2, mtx3); // 安全地同时锁定三个互斥量
    // 临界区
    // ...
} // 自动按 mtx3, mtx2, mtx1 顺序解锁
```

```cpp
std::mutex mtx_a, mtx_b;

// ❌ 使用 lock_guard（危险）
void transfer_bad(Account& from, Account& to, int amount) {
    std::lock_guard<std::mutex> lock_a(from.mtx);
    std::lock_guard<std::mutex> lock_b(to.mtx); // 可能死锁
    // 转账逻辑
}

// ✅ 使用 scoped_lock（安全）
void transfer_good(Account& from, Account& to, int amount) {
    std::scoped_lock lock(from.mtx, to.mtx); // 安全，无死锁风险
    // 转账逻辑
}

```