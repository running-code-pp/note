- [\_\_cplusplus](#__cplusplus)
- [extern "C"](#extern-c)
- [\_\_has\_include(\<header\_file\>)](#__has_includeheader_file)
- [\_\_cpp\_lib\_three\_way\_comparison\&\&\_\_cpp\_impl\_three\_way\_comparison](#__cpp_lib_three_way_comparison__cpp_impl_three_way_comparison)
- [\_\_cpp\_impl\_coroutine](#__cpp_impl_coroutine)
- [两层宏拼接技巧](#两层宏拼接技巧)
- [ifdef 和 if defined()](#ifdef-和-if-defined)
- [\_\_has\_cpp\_attribute(...)](#__has_cpp_attribute)
- [\[\[likely\]\] \[\[unlikely\]\] (cpp17)](#likely-unlikely-cpp17)
- [\_\_always\_inline\_\_强制内联](#__always_inline__强制内联)
- [cpu高速缓存的跨平台语言支持](#cpu高速缓存的跨平台语言支持)


# __cplusplus
这是一个在cpp编译器中定义的宏，表示当前代码是C++编译器编译的,标识了C++版本
C++98 / C++03: 199711L
C++11: 201103L
C++14: 201402L
C++17: 201703L
C++20: 202002L
C++23: 202302L

**应用场景**
常常在为了处理不同版本或编译器对于语言特性给支持程度不同的情况，例如async_simple中的这段代码:
如果不支持coroutine那么就是用自己实现的有栈协程
```cpp
#if (__cplusplus <= 201703L && !defined(_MSC_VER)) || \
    (defined(__clang__) && defined(__GLIBCXX__) && \
     (__GLIBCXX__ < 20210408))
#define USE_SELF_DEFINED_COROUTINE
#endif
```

# extern "C"
在c++中函数名支持重载和名字修饰(namespace),这使得函数编译之后变得复杂

extern "C" 是c++中的一种语言连接贵伐，表示该函数或代码块应该按照C的方式进行编译和链接，这样这些函数就可以被其他语言调用

```cpp
#ifdef __cplusplus
extern "C" {
#endif

void my_c_function();  // 函数声明，C 和 C++ 均可以使用

#ifdef __cplusplus
}
#endif
```

# __has_include(<header_file>)
c++17引入的一个运算符，处理预处理指令,检查指定的头文件是否可以包含在程序中
```cpp
#if __has_include(<header_file>)
    // Code to be executed if <header_file> is available
#else
    // Code to be executed if <header_file> is not available
#endif
```

# __cpp_lib_three_way_comparison&&__cpp_impl_three_way_comparison

判断是否支持三路运算符(C++20)
```cpp
#if defined(__cpp_lib_three_way_comparison) && \
    defined(__cpp_impl_three_way_comparison)
#define HAS_THREE_WAY_COMPARISON
#endif

#if defined(HAS_THREE_WAY_COMPARISON)
#include <compare>
#endif

```

# __cpp_impl_coroutine
判断是否支持非实验性的coroutine
```cpp
#if defined(__cpp_impl_coroutine) && __cpp_impl_coroutine >= 201902L
#define HAS_NON_EXPERIMENTAL_COROUTINE
#endif
```


# 两层宏拼接技巧
场景: 使用宏拼接连个字符串
首先我们想当然会想到下面这种
```cpp
#define CONCAT(s1,s2) s1##s2
```

这种方式对于一般变量直接拼接没问题，但是如果其中还有宏的话就会导致里面的宏不会展开，例如
```cpp
CONCAT(linenum:,__LINE__)
```
假设当前__LINE__展开是15，那么我们预期的展开效果是linenum:15
但是实际上展开的效果确实 linenum:__LINE__

如果我们希望达到预期的效果，则需要使用两层宏
```cpp
#define CONCAT2(s1,s2)  s1##s2
#define CONCAT(s1,s2) CONCAT2(s1,s2)
```
这样我们使用CONCAT的时候当首先转化为CONCAT2的时候就会把s1,s2中的宏替换掉，然后展开CONCAT2的时候就不会出现内部宏未展开的情况了

# ifdef 和 if defined()
都是用来做条件编译的，区别在于if defined支持运算，

例如:
```cpp
#if defined(__GNUC__) || defined(__clang__)
    // GCC 或 Clang
#endif

#if defined(__GNUC__) && defined(__linux__)
    // 只在 GCC + Linux 下
#endif

#if !defined(__GNUC__)
    // 不是 GCC
#endif
```

# __has_cpp_attribute(...)
预处理器指令中的条件表达式，检查当前编译器是否支持c++中的某个属性

# [[likely]] [[unlikely]] (cpp17)
c++17中引入的两个属性，对于现代cpu为了提高性能，会预测代码的执行路径，如果预测错误会造成性能损失
- [[likely]] 告诉编译器，编辑的语句或分支极有可能被执行
- [[unlikely]] 告诉编译器，编辑的语句或分支极不可能被执行

```cpp
#if __has_cpp_attribute(likely) && __has_cpp_attribute(unlikely)
#define LIKELY [[likely]]
#define UNLIKELY [[unlikely]]
#else
#define LIKELY
#define UNLIKELY
#endif
```

# __always_inline__强制内联

c++中的inline只是一个建议性的关键字，编译器不一定会把指定函数变成真内联

__attrribute__((__always_inline__)) 这是gcc和clang编译器拓展的语法，可以强制编译器尽可能地将函数内联，即使编译器认为内联不划算（体积比较大）

```cpp
#ifdef _WIN32
#define INLINE
#else
#define INLINE __attribute__((__always_inline__)) inline
#endif

```


# cpu高速缓存的跨平台语言支持
```cpp
- std::hardware_destructive_interference_size
目的：避免伪共享（false sharing）
含义：两个对象至少需要相距这么远，才能避免在同一缓存行中相互干扰
使用场景：当你希望不同线程访问的数据不要在同一缓存行中

- std::hardware_constructive_interference_size
目的：促进共享，提高缓存局部性
含义：两个对象在这个距离内，很可能在同一缓存行中，能够一起被加载
使用场景：当你希望相关数据能够一起被缓存，提高访问效率
```
