# 概述
互斥锁加锁失败后，线程会释放 CPU ，给其他线程；
自旋锁加锁失败后，线程会忙等待，直到它拿到锁；

**使用互斥锁的缺点**
```
会有两次线程上下文切换的成本：
当线程加锁失败时，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把 CPU 切换给其他线程运行；
接着，当锁被释放时，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把 CPU 切换给该线程运行。
```
# 适用场景
当你认为等待锁浪费的cpu时间这个开销小于两次线程上下文切换的开销的时候，就应该使用自旋锁

# c++标准实现 

```cpp
class SpinLock{
    public:
    void lock(){
        while(_atomic_flag.test_and_set(std::memory_order:acquire)){}
    }
    void unlock(){
        _atomic_flag.clear(std::memory_order::release);
    }

    private:
    std::atomic_flag _atomic_flag{ATOMIC_FLAG_INIT};
};

```

**优化版本**

```cpp


```

# FIFO的公平自旋锁 TicketSpinLock

## 概述
类似于银行取号机:
- 每个线程来的时候先取号
- 服务台叫号
- 号码匹配的线程进入临界区
- 先来先服务，完全公平

```cpp
    class TicketSpinLock
    {
    public:
        TicketSpinLock() : _ticket(0), _next(0) {}

        P_NOTINLINE unsigned int lock()
        {
            // 获取票据
           auto ticket = _ticket.fetch_add(1, std::memory_order_relaxed);
            
           /**
            * while(!(ticket == _next.load(std::memory_order_acquire))){}
            * 优化如下
            */
            // 等待轮到自己
            for(;;){
                // 排在前面的人数
                auto position = ticket - _next.load(std::memory_order_acquire);
                P_LIKELY if(!position){
                    break;
                }
                // 根据前面排队长度动态调整等待时间，减小内存总线压力
                do{
                    CPU_PAUSE();
                }while(--position);
            }
            return ticket;
        }

        void unlock()
        {
            // 服务结束，发出下一个票据
            unlock(_next.load(std::memory_order_relaxed)+1);
        }

        void unlock(unsigned int ticket){
            _next.store(ticket+1,std::memory_order_release);
        }

    private:
        // 缓存行对齐，避免伪共享
        alignas(CACHE_LINE_SIZE) std::atomic<unsigned int> _ticket;
        alignas(CACHE_LINE_SIZE) std::atomic<unsigned int> _next;
    };
```

# 两种自旋锁的详细对比

## 1. 基本自旋锁 (SpinLock) vs 票据自旋锁 (TicketSpinLock)

| 特性 | 基本自旋锁 | 票据自旋锁 |
|------|------------|------------|
| **公平性** | 不公平，可能饿死某些线程 | 完全公平，FIFO顺序 |
| **实现机制** | 单个原子标志位竞争 | 取号机制，排队等待 |
| **性能开销** | 低延迟，简单实现 | 稍高延迟，但避免缓存抖动 |
| **缓存友好性** | 所有线程竞争同一缓存行 | 分离ticket和next，减少缓存竞争 |
| **适用场景** | 锁持有时间短，线程少 | 需要公平性，线程较多 |

## 2. 具体区别分析

### 基本自旋锁问题：
```cpp
// 问题1：不公平竞争
void SpinLock::lock() {
    while(_atomic_flag.test_and_set(std::memory_order_acquire)) {
        // 所有线程都在这里自旋，没有顺序保证
        // 可能某个线程一直抢不到锁（饿死）
    }
}
```
## 3. 性能特点对比

### 基本自旋锁：
- ✅ **优点**：实现简单，低延迟
- ❌ **缺点**：
  - 缓存抖动严重（所有CPU核心竞争同一缓存行）
  - 不公平，可能导致某些线程饿死
  - 高竞争下性能急剧下降

### 票据自旋锁：
- ✅ **优点**：
  - 完全公平，FIFO顺序
  - 缓存友好（ticket和next分离对齐）
  - 智能等待机制减少总线压力
  - 高竞争下性能更稳定
- ❌ **缺点**：
  - 实现复杂度稍高
  - 轻微的额外内存开销
