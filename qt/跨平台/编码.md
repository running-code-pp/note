除了windows之外几乎所有主流os都是用utf8作为默认编码
所以一般统一使用utf8,windows上做特殊处理转成utf8

# 处理main入参
```
#if (defined(_MSCVER) || defined(_MSC_VER))
    // // On MSVC under Windows, we need to manually retrieve the command-line arguments and convert them from UTF-16 to UTF-8.
    // // This prevents data loss if there are any characters that wouldn't fit in the local ANSI code page.


    auto utf8_encode = [](const wchar_t *wstr) -> std::string
    {
        int size_needed = WideCharToMultiByte(CP_UTF8, 0, &wstr[0], -1, 0, 0, 0, 0);
        std::string strTo(size_needed, 0);
        WideCharToMultiByte(CP_UTF8, 0, &wstr[0], -1, &strTo[0], size_needed, 0, 0);
        return strTo;
    };

    int argc_utf16 = 0;
    wchar_t **argv_utf16 = CommandLineToArgvW(GetCommandLineW(), &argc_utf16);
    std::vector<std::string> argsUtf8; // store data
    for (int i = 0; i < argc_utf16; ++i)
    {
        argsUtf8.push_back(utf8_encode(argv_utf16[i]));
    }

    std::vector<char *> argsUtf8_с; // convert to char*
    for (std::string &arg : argsUtf8)
    {
        argsUtf8_с.push_back(arg.data());
    }

    // Don't use the arguments passed to main(), because they're in the local ANSI code page.
    Q_UNUSED(argc);
    Q_UNUSED(argv);

    int argcFinal = argc_utf16;
    char **argvFinal = argsUtf8_с.data();
#else

    int argcFinal = argc;
    char **argvFinal = argv;

#endif
```